name: iOS TestFlight (MAUI) ‚Äî p√∫blico ‚ûú privado

on:
  workflow_dispatch:

concurrency:
  group: ios-testflight-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  DOTNET_VERSION: 8.0.415
  XCODE_VERSION: "16.1"   # iOS 18 SDK requerido por Microsoft.iOS 18.x

jobs:
  build-and-upload:
    runs-on: macos-14

    steps:
      # 1) Repo CI (este)
      - name: Checkout (CI repo)
        uses: actions/checkout@v4

      # 2) Repo privado con el c√≥digo
      - name: Checkout private source
        uses: actions/checkout@v4
        with:
          repository: Salvacuentacuentos/Eraseunaapp
          # ref: master        # <- ajusta si tu rama es otra
          path: source/repos
          ssh-key: ${{ secrets.PRIVATE_REPO_DEPLOY_KEY }}

      # 3) Herramientas (Xcode + punteros de SDK)
      - name: Select Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: ${{ env.XCODE_VERSION }}

      - name: Point .NET to selected Xcode (DEVELOPER_DIR & MD_APPLE_SDK_ROOT)
        run: |
          set -euo pipefail
          XCODE_DEV="$(xcode-select -p)"                                     # /Applications/Xcode_16.1.app/Contents/Developer
          XCODE_APP="$(dirname "$(dirname "$XCODE_DEV")")"                   # /Applications/Xcode_16.1.app
          echo "xcode-select -p => $XCODE_DEV"
          xcodebuild -version
          echo "DEVELOPER_DIR=$XCODE_DEV"       >> "$GITHUB_ENV"
          echo "MD_APPLE_SDK_ROOT=$XCODE_APP"   >> "$GITHUB_ENV"
          echo "‚úÖ Set MD_APPLE_SDK_ROOT=$XCODE_APP"

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.sln', '**/*.csproj') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Install MAUI workloads (iOS)
        run: |
          set -euo pipefail
          dotnet --info
          dotnet workload install maui maui-ios --source https://api.nuget.org/v3/index.json

      # 4) Detectar autom√°ticamente el csproj (maneja Eraseunaapp/Eraseunaapp/Eraseunaapp.csproj)
- name: Locate project (auto)
  id: proj
  run: |
    set -euo pipefail
    echo "Contenido de source/repos:"
    ls -la source/repos || true

    # Buscar el .csproj m√°s profundo llamado Eraseunaapp.csproj dentro del repo privado
    CS=$(find source/repos -type f -name "Eraseunaapp.csproj" -print \
         | awk '{ print length, $0 }' | sort -nr | head -n1 | cut -d" " -f2-)

    # Fallback si no lo encuentra con ese nombre exacto
    if [ -z "${CS:-}" ]; then
      CS=$(find source/repos -type f -name "*.csproj" -print \
           | awk '{ print length, $0 }' | sort -nr | head -n1 | cut -d" " -f2-)
    fi

    # Caso t√≠pico: hay carpeta duplicada "Eraseunaapp/Eraseunaapp"
    # Si existe una subcarpeta con otro Eraseunaapp.csproj, preferir la m√°s interna
    if [ -n "${CS:-}" ]; then
      BASE_DIR="$(dirname "$CS")"
      if [ -d "$BASE_DIR/Eraseunaapp" ] && [ -f "$BASE_DIR/Eraseunaapp/Eraseunaapp.csproj" ]; then
        CS="$BASE_DIR/Eraseunaapp/Eraseunaapp.csproj"
      fi
    fi

    if [ -z "${CS:-}" ] || [ ! -f "$CS" ]; then
      echo "No se encontr√≥ el .csproj. Listado de proyectos:" >&2
      find source/repos -type f -name "*.csproj" -print >&2
      exit 1
    fi

    DIR=$(dirname "$CS")
    echo "csproj=$CS"   >> "$GITHUB_OUTPUT"
    echo "srcdir=$DIR"  >> "$GITHUB_OUTPUT"

    echo "‚úÖ Proyecto: $CS"
    echo "üìÅ Carpeta:  $DIR"
    echo "Listado de la carpeta del proyecto:"
    ls -la "$DIR"


      # 5) Fijar SDK .NET 8 en el c√≥digo (evita usar .NET 9)
      - name: Pin .NET 8 SDK (global.json)
        working-directory: ${{ steps.proj.outputs.srcdir }}
        run: |
          set -euo pipefail
          cat > global.json <<'JSON'
          {
            "sdk": {
              "version": "8.0.415",
              "rollForward": "disable"
            }
          }
          JSON
          echo "Usando dotnet SDK:" && dotnet --version

      - name: Assert SDK 8.0.415
        working-directory: ${{ steps.proj.outputs.srcdir }}
        run: |
          set -euo pipefail
          V=$(dotnet --version)
          [ "$V" = "8.0.415" ] || { echo "::error::Usando SDK $V en vez de 8.0.415"; exit 1; }

      # 6) Workload restore (iOS) ‚Äî SDK 8 desde srcdir, csproj absoluto y TFM forzado
      - name: Workload restore (iOS)
        working-directory: ${{ steps.proj.outputs.srcdir }}
        run: |
          set -euo pipefail
          echo "SRC: $(pwd)"
          echo "CSPROJ: ${{ steps.proj.outputs.csproj }}"
          test -f "${{ steps.proj.outputs.csproj }}" || { echo "::error::No existe el csproj en esa ruta"; exit 1; }
          dotnet --version     # deber√≠a ser 8.0.415
          dotnet workload restore --project "${{ steps.proj.outputs.csproj }}" \
            -p:TargetFramework=net8.0-ios \
            -p:TargetFrameworks=net8.0-ios

      # 7) Restore (iOS only) ‚Äî idem
      - name: Restore (iOS only)
        working-directory: ${{ steps.proj.outputs.srcdir }}
        run: |
          set -euo pipefail
          dotnet --version     # deber√≠a ser 8.0.415
          dotnet restore "${{ steps.proj.outputs.csproj }}" \
            -p:TargetFramework=net8.0-ios \
            -p:TargetFrameworks=net8.0-ios \
            -p:CheckEolTargetFramework=false \
            -p:SuppressTfmSupportBuildCheck=true \
            -p:TreatWarningsAsErrors=false \
            -p:NoWarn=NU1605

      # 8) Keychain
      - name: Create & unlock keychain
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" login.keychain

      - name: Import .p12 into keychain and allow codesign (robust)
        shell: bash
        env:
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
          IOS_DISTRIBUTION_P12_BASE64: ${{ secrets.IOS_DISTRIBUTION_P12_BASE64 }}
          IOS_DISTRIBUTION_P12_PASSWORD: ${{ secrets.IOS_DISTRIBUTION_P12_PASSWORD }}
        run: |
          set -euo pipefail

          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          P12_PATH="$RUNNER_TEMP/dist.p12"

          # 0) Sanity checks
          if [ -z "${IOS_DISTRIBUTION_P12_BASE64:-}" ]; then
            echo "‚ùå IOS_DISTRIBUTION_P12_BASE64 est√° vac√≠o."; exit 1; fi
          if [ -z "${IOS_DISTRIBUTION_P12_PASSWORD:-}" ]; then
            echo "‚ùå IOS_DISTRIBUTION_P12_PASSWORD est√° vac√≠o."; exit 1; fi

          # 2) Decodificar Base64 ‚Üí .p12
          printf %s "$IOS_DISTRIBUTION_P12_BASE64" | base64 --decode > "$P12_PATH" || {
            echo "‚ùå Fallo al decodificar el Base64 del .p12"; exit 1; }
          if [ ! -s "$P12_PATH" ]; then
            echo "‚ùå El .p12 decodificado est√° vac√≠o."; exit 1; fi

          # 3) Validar contrase√±a
          if ! openssl pkcs12 -in "$P12_PATH" -passin pass:"$IOS_DISTRIBUTION_P12_PASSWORD" -info -nokeys >/dev/null 2>&1; then
            echo "‚ùå La contrase√±a del .p12 no es v√°lida (MAC verification)."
            exit 1
          fi

          # 4) Importar (con fallback a legacy)
          if security import "$P12_PATH" -k "$KEYCHAIN_PATH" -P "$IOS_DISTRIBUTION_P12_PASSWORD" -A -f pkcs12 \
              -T /usr/bin/codesign -T /usr/bin/security; then
            echo "‚úÖ Import OK (p12 original)."
          else
            echo "‚ÑπÔ∏è Reempaquetando .p12 a formato legacy y reintentando‚Ä¶"
            openssl pkcs12 -in "$P12_PATH" -passin pass:"$IOS_DISTRIBUTION_P12_PASSWORD" -nodes -out "$RUNNER_TEMP/tmp.pem"
            openssl pkcs12 -export -in "$RUNNER_TEMP/tmp.pem" -passout pass:"$IOS_DISTRIBUTION_P12_PASSWORD" -out "$RUNNER_TEMP/dist-legacy.p12"
            security import "$RUNNER_TEMP/dist-legacy.p12" -k "$KEYCHAIN_PATH" -P "$IOS_DISTRIBUTION_P12_PASSWORD" -A -f pkcs12 \
              -T /usr/bin/codesign -T /usr/bin/security
            echo "‚úÖ Import OK (formato legacy)."
          fi

          # 5) Permisos + exponer nombre del certificado
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          CERT_NAME="$(security find-identity -v -p codesigning "$KEYCHAIN_PATH" | sed -n 's/.*"\(.*\)".*/\1/p' | head -n1)"
          echo "CERT_NAME=$CERT_NAME" >> "$GITHUB_ENV"
          echo "üîê Certificado: $CERT_NAME"

      - name: Install provisioning profile (robust)
        env:
          IOS_APPSTORE_PROFILE_B64: ${{ secrets.IOS_APPSTORE_PROFILE_B64 }}
        run: |
          set -euo pipefail

          if [ -z "${IOS_APPSTORE_PROFILE_B64:-}" ]; then
            echo "‚ùå IOS_APPSTORE_PROFILE_B64 est√° vac√≠o o no definido."
            exit 1
          fi

          PROFILE_RAW="$RUNNER_TEMP/app.mobileprovision"
          printf %s "$IOS_APPSTORE_PROFILE_B64" | base64 --decode > "$PROFILE_RAW" || {
            echo "‚ùå Base64 inv√°lido para el .mobileprovision"; exit 1; }

          BYTES=$(wc -c < "$PROFILE_RAW" | tr -d ' ')
          if [ "$BYTES" -lt 1000 ]; then
            echo "‚ùå El .mobileprovision decodificado es demasiado peque√±o ($BYTES bytes)."
            exit 1
          fi

          security cms -D -i "$PROFILE_RAW" > "$RUNNER_TEMP/profile.plist"
          PP_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$RUNNER_TEMP/profile.plist")
          PP_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$RUNNER_TEMP/profile.plist")
          APP_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' "$RUNNER_TEMP/profile.plist" || true)
          BUNDLE_ID=$(echo "$APP_ID" | sed 's/^[A-Z0-9]*\.//')

          echo "PP_UUID=$PP_UUID" >> $GITHUB_ENV
          echo "PP_NAME=$PP_NAME" >> $GITHUB_ENV
          echo "PP_BUNDLE_ID=$BUNDLE_ID" >> $GITHUB_ENV
          echo "üìÑ Profile: $PP_NAME ($PP_UUID) ‚Äî Bundle ID: $BUNDLE_ID"

          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$PROFILE_RAW" "$HOME/Library/MobileDevice/Provisioning Profiles/$PP_UUID.mobileprovision"

      # 9) Build number √∫nico (timestamp UTC)
      - name: Compute build number (UTC timestamp)
        id: buildno
        shell: bash
        run: |
          set -euo pipefail
          BN=$(date -u +%Y%m%d%H%M%S)   # 14 d√≠gitos, v√°lido para CFBundleVersion
          echo "BUILD_NUMBER=$BN" >> $GITHUB_ENV
          echo "üî¢ BUILD_NUMBER=$BN"

      # 10) Publicar y generar .ipa
      - name: Publish (.xcarchive) + .ipa
        working-directory: ${{ steps.proj.outputs.srcdir }}
        run: |
          set -euo pipefail
          dotnet publish "$(basename "${{ steps.proj.outputs.csproj }}")" \
            -c Release \
            -f net8.0-ios \
            -p:RuntimeIdentifier=ios-arm64 \
            -p:ArchiveOnBuild=true \
            -p:BuildIpa=true \
            -p:ApplicationVersion=${{ env.BUILD_NUMBER }} \
            -p:CFBundleVersion=${{ env.BUILD_NUMBER }} \
            -p:CFBundleIconName=AppIcon \
            -p:MtouchLink=SdkOnly \
            -p:PublishTrimmed=true \
            -p:CodesignKey="${{ env.CERT_NAME }}" \
            -p:ProvisioningProfileUuid="${{ env.PP_UUID }}" \
            -p:TreatWarningsAsErrors=false \
            -p:NoWarn=NU1605

      - name: Find IPA
        id: findipa
        run: |
          set -euo pipefail
          IPA_PATH="$(find "${{ steps.proj.outputs.srcdir }}/bin/Release/net8.0-ios/ios-arm64/publish" -type f -name "*.ipa" -print -quit)"
          if [ -z "$IPA_PATH" ]; then
            IPA_PATH="$(find "${{ steps.proj.outputs.srcdir }}/bin/Release/net8.0-ios/ios-arm64" -type f -name "*.ipa" -print -quit)"
          fi
          echo "ipa=$IPA_PATH" >> $GITHUB_OUTPUT
          test -f "$IPA_PATH" && echo "IPA: $IPA_PATH"

      - name: Inspect IPA bundle id, versions & icon name
        if: steps.findipa.outputs.ipa != ''
        shell: bash
        run: |
          set -euo pipefail
          IPA="${{ steps.findipa.outputs.ipa }}"
          PLIST_XML="$(unzip -p "$IPA" Payload/*.app/Info.plist | plutil -convert xml1 -o - -)"
          BID="$(echo "$PLIST_XML" | /usr/libexec/PlistBuddy -c 'Print :CFBundleIdentifier' /dev/stdin)"
          SVER="$(echo "$PLIST_XML" | /usr/libexec/PlistBuddy -c 'Print :CFBundleShortVersionString' /dev/stdin || true)"
          BNUM="$(echo "$PLIST_XML" | /usr/libexec/PlistBuddy -c 'Print :CFBundleVersion' /dev/stdin)"
          ICON="$(echo "$PLIST_XML" | /usr/libexec/PlistBuddy -c 'Print :CFBundleIconName' /dev/stdin || true)"
          echo "BundleId: $BID"
          echo "DisplayVersion (CFBundleShortVersionString): ${SVER:-<missing>}"
          echo "BuildNumber (CFBundleVersion): $BNUM"
          echo "IconName (CFBundleIconName): ${ICON:-<missing>}"
          if [ -z "${ICON:-}" ]; then
            echo "‚ö†Ô∏è  Aviso: falta CFBundleIconName=AppIcon en Info.plist (MAUI suele generarlo si <MauiIcon> existe)."
          fi

      # 11) Subir a TestFlight
      - name: Upload to TestFlight
        if: steps.findipa.outputs.ipa != ''
        env:
          APPSTORE_ISSUER_ID:   ${{ secrets.APPSTORE_ISSUER_ID }}
          APPSTORE_KEY_ID:      ${{ secrets.APPSTORE_KEY_ID }}
          APPSTORE_PRIVATE_KEY: ${{ secrets.APPSTORE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          IPA="${{ steps.findipa.outputs.ipa }}"
          mkdir -p "$HOME/.appstoreconnect/private_keys"
          KEYFILE="$HOME/.appstoreconnect/private_keys/AuthKey_${APPSTORE_KEY_ID}.p8"

          CONTENT="${APPSTORE_PRIVATE_KEY}"
          if [ -z "$CONTENT" ]; then
            echo "‚ùå APPSTORE_PRIVATE_KEY est√° vac√≠o."; exit 1; fi

          if echo "$CONTENT" | grep -q "BEGIN PRIVATE KEY"; then
            printf '%b' "$CONTENT" > "$KEYFILE"
          else
            if printf '%s' "$CONTENT" | base64 -d > "$KEYFILE" 2>/dev/null; then
              :
            else
              printf '%b' "$CONTENT" > "$KEYFILE"
            fi
          fi
          chmod 600 "$KEYFILE"

          if ! xcrun altool --list-providers --apiKey "$APPSTORE_KEY_ID" --apiIssuer "$APPSTORE_ISSUER_ID" >/dev/null 2>&1; then
            echo "‚ùå Fall√≥ la autenticaci√≥n con App Store Connect."
            exit 1
          fi

          xcrun altool --upload-app -f "$IPA" -t ios --apiKey "$APPSTORE_KEY_ID" --apiIssuer "$APPSTORE_ISSUER_ID" --verbose

      # 12) Artefactos
      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-artifacts
          path: |
            ${{ steps.findipa.outputs.ipa }}
            $HOME/Library/Logs/DiagnosticReports/*
          if-no-files-found: ignore
